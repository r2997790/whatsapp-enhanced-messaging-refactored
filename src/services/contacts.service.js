const fs = require('fs').promises;\nconst path = require('path');\nconst config = require('../config/config');\nconst logger = require('../utils/logger');\nconst { generateId, isValidPhoneNumber, formatDate } = require('../utils/helpers');\n\nclass ContactsService {\n  constructor() {\n    this.dataPath = path.join(config.database.path, config.database.contacts);\n    this.contacts = [];\n    this.groups = [];\n    this.initialize();\n  }\n\n  async initialize() {\n    try {\n      // Ensure data directory exists\n      const dataDir = config.database.path;\n      await fs.mkdir(dataDir, { recursive: true });\n      \n      // Load existing contacts\n      await this.loadContacts();\n      \n      logger.info(`ContactsService initialized with ${this.contacts.length} contacts`);\n    } catch (error) {\n      logger.error('Failed to initialize ContactsService:', error);\n      throw error;\n    }\n  }\n\n  async loadContacts() {\n    try {\n      const data = await fs.readFile(this.dataPath, 'utf8');\n      const parsed = JSON.parse(data);\n      this.contacts = parsed.contacts || [];\n      this.groups = parsed.groups || [];\n    } catch (error) {\n      if (error.code === 'ENOENT') {\n        // File doesn't exist, start with empty data\n        this.contacts = [];\n        this.groups = [];\n        await this.saveContacts();\n      } else {\n        logger.error('Error loading contacts:', error);\n        throw error;\n      }\n    }\n  }\n\n  async saveContacts() {\n    try {\n      const data = {\n        contacts: this.contacts,\n        groups: this.groups,\n        lastUpdated: new Date().toISOString()\n      };\n      await fs.writeFile(this.dataPath, JSON.stringify(data, null, 2));\n    } catch (error) {\n      logger.error('Error saving contacts:', error);\n      throw error;\n    }\n  }\n\n  async addContact(contactData) {\n    try {\n      const { name, phone, email, tags, groupIds } = contactData;\n      \n      // Validate required fields\n      if (!name || !phone) {\n        throw new Error('Name and phone are required');\n      }\n\n      if (!isValidPhoneNumber(phone)) {\n        throw new Error('Invalid phone number');\n      }\n\n      // Check for duplicate phone number\n      const existingContact = this.contacts.find(c => c.phone === phone);\n      if (existingContact) {\n        throw new Error('Contact with this phone number already exists');\n      }\n\n      const contact = {\n        id: generateId(),\n        name: name.trim(),\n        phone: phone.trim(),\n        email: email?.trim() || '',\n        tags: tags || [],\n        groupIds: groupIds || [],\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString(),\n        lastMessageSent: null,\n        messageCount: 0\n      };\n\n      this.contacts.push(contact);\n      await this.saveContacts();\n      \n      logger.info(`Contact added: ${name} (${phone})`);\n      return contact;\n    } catch (error) {\n      logger.error('Error adding contact:', error);\n      throw error;\n    }\n  }\n\n  async updateContact(contactId, updateData) {\n    try {\n      const contactIndex = this.contacts.findIndex(c => c.id === contactId);\n      if (contactIndex === -1) {\n        throw new Error('Contact not found');\n      }\n\n      const contact = this.contacts[contactIndex];\n      \n      // Validate phone number if being updated\n      if (updateData.phone && updateData.phone !== contact.phone) {\n        if (!isValidPhoneNumber(updateData.phone)) {\n          throw new Error('Invalid phone number');\n        }\n        \n        // Check for duplicate\n        const existingContact = this.contacts.find(c => c.phone === updateData.phone && c.id !== contactId);\n        if (existingContact) {\n          throw new Error('Contact with this phone number already exists');\n        }\n      }\n\n      // Update contact\n      Object.assign(contact, updateData, {\n        updatedAt: new Date().toISOString()\n      });\n\n      await this.saveContacts();\n      \n      logger.info(`Contact updated: ${contactId}`);\n      return contact;\n    } catch (error) {\n      logger.error('Error updating contact:', error);\n      throw error;\n    }\n  }\n\n  async deleteContact(contactId) {\n    try {\n      const contactIndex = this.contacts.findIndex(c => c.id === contactId);\n      if (contactIndex === -1) {\n        throw new Error('Contact not found');\n      }\n\n      const contact = this.contacts[contactIndex];\n      this.contacts.splice(contactIndex, 1);\n      await this.saveContacts();\n      \n      logger.info(`Contact deleted: ${contact.name} (${contact.phone})`);\n      return { success: true };\n    } catch (error) {\n      logger.error('Error deleting contact:', error);\n      throw error;\n    }\n  }\n\n  async getContacts(filters = {}) {\n    try {\n      let filteredContacts = [...this.contacts];\n\n      // Apply filters\n      if (filters.search) {\n        const search = filters.search.toLowerCase();\n        filteredContacts = filteredContacts.filter(contact =>\n          contact.name.toLowerCase().includes(search) ||\n          contact.phone.includes(search) ||\n          contact.email.toLowerCase().includes(search)\n        );\n      }\n\n      if (filters.groupId) {\n        filteredContacts = filteredContacts.filter(contact =>\n          contact.groupIds.includes(filters.groupId)\n        );\n      }\n\n      if (filters.tags && filters.tags.length > 0) {\n        filteredContacts = filteredContacts.filter(contact =>\n          filters.tags.some(tag => contact.tags.includes(tag))\n        );\n      }\n\n      // Sort by name\n      filteredContacts.sort((a, b) => a.name.localeCompare(b.name));\n\n      return filteredContacts;\n    } catch (error) {\n      logger.error('Error getting contacts:', error);\n      throw error;\n    }\n  }\n\n  async getContact(contactId) {\n    try {\n      const contact = this.contacts.find(c => c.id === contactId);\n      if (!contact) {\n        throw new Error('Contact not found');\n      }\n      return contact;\n    } catch (error) {\n      logger.error('Error getting contact:', error);\n      throw error;\n    }\n  }\n\n  async importContacts(contactsData) {\n    try {\n      const results = {\n        imported: 0,\n        skipped: 0,\n        errors: []\n      };\n\n      for (const contactData of contactsData) {\n        try {\n          // Skip if phone already exists\n          const existingContact = this.contacts.find(c => c.phone === contactData.phone);\n          if (existingContact) {\n            results.skipped++;\n            continue;\n          }\n\n          await this.addContact(contactData);\n          results.imported++;\n        } catch (error) {\n          results.errors.push({\n            contact: contactData,\n            error: error.message\n          });\n        }\n      }\n\n      logger.info(`Contacts import completed: ${results.imported} imported, ${results.skipped} skipped, ${results.errors.length} errors`);\n      return results;\n    } catch (error) {\n      logger.error('Error importing contacts:', error);\n      throw error;\n    }\n  }\n\n  async exportContacts(format = 'json') {\n    try {\n      if (format === 'json') {\n        return {\n          contacts: this.contacts,\n          exportedAt: new Date().toISOString(),\n          total: this.contacts.length\n        };\n      } else if (format === 'csv') {\n        const headers = ['Name', 'Phone', 'Email', 'Tags', 'Groups', 'Created At'];\n        const rows = this.contacts.map(contact => [\n          contact.name,\n          contact.phone,\n          contact.email,\n          contact.tags.join(';'),\n          contact.groupIds.join(';'),\n          formatDate(new Date(contact.createdAt))\n        ]);\n        \n        return {\n          headers,\n          rows,\n          csv: [headers, ...rows].map(row => row.join(',')).join('\\n')\n        };\n      }\n      \n      throw new Error('Unsupported export format');\n    } catch (error) {\n      logger.error('Error exporting contacts:', error);\n      throw error;\n    }\n  }\n\n  async updateMessageStats(contactId) {\n    try {\n      const contact = this.contacts.find(c => c.id === contactId);\n      if (contact) {\n        contact.lastMessageSent = new Date().toISOString();\n        contact.messageCount = (contact.messageCount || 0) + 1;\n        await this.saveContacts();\n      }\n    } catch (error) {\n      logger.error('Error updating message stats:', error);\n    }\n  }\n\n  getStats() {\n    return {\n      totalContacts: this.contacts.length,\n      totalGroups: this.groups.length,\n      recentContacts: this.contacts\n        .sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt))\n        .slice(0, 5),\n      topTags: this.getTopTags()\n    };\n  }\n\n  getTopTags() {\n    const tagCounts = {};\n    this.contacts.forEach(contact => {\n      contact.tags.forEach(tag => {\n        tagCounts[tag] = (tagCounts[tag] || 0) + 1;\n      });\n    });\n    \n    return Object.entries(tagCounts)\n      .sort(([,a], [,b]) => b - a)\n      .slice(0, 10)\n      .map(([tag, count]) => ({ tag, count }));\n  }\n}\n\nmodule.exports = ContactsService;