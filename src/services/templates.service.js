const fs = require('fs').promises;\nconst path = require('path');\nconst config = require('../config/config');\nconst logger = require('../utils/logger');\nconst { generateId, formatDate } = require('../utils/helpers');\n\nclass TemplatesService {\n  constructor() {\n    this.dataPath = path.join(config.database.path, config.database.templates);\n    this.templates = [];\n    this.initialize();\n  }\n\n  async initialize() {\n    try {\n      // Ensure data directory exists\n      const dataDir = config.database.path;\n      await fs.mkdir(dataDir, { recursive: true });\n      \n      // Load existing templates\n      await this.loadTemplates();\n      \n      logger.info(`TemplatesService initialized with ${this.templates.length} templates`);\n    } catch (error) {\n      logger.error('Failed to initialize TemplatesService:', error);\n      throw error;\n    }\n  }\n\n  async loadTemplates() {\n    try {\n      const data = await fs.readFile(this.dataPath, 'utf8');\n      const parsed = JSON.parse(data);\n      this.templates = parsed.templates || [];\n    } catch (error) {\n      if (error.code === 'ENOENT') {\n        // File doesn't exist, start with default templates\n        this.templates = this.getDefaultTemplates();\n        await this.saveTemplates();\n      } else {\n        logger.error('Error loading templates:', error);\n        throw error;\n      }\n    }\n  }\n\n  async saveTemplates() {\n    try {\n      const data = {\n        templates: this.templates,\n        lastUpdated: new Date().toISOString()\n      };\n      await fs.writeFile(this.dataPath, JSON.stringify(data, null, 2));\n    } catch (error) {\n      logger.error('Error saving templates:', error);\n      throw error;\n    }\n  }\n\n  getDefaultTemplates() {\n    return [\n      {\n        id: generateId(),\n        name: 'Welcome Message',\n        content: 'Hello {{name}}, welcome to our service! We\\'re excited to have you on board.',\n        category: 'welcome',\n        tags: ['greeting', 'welcome', 'onboarding'],\n        variables: ['name'],\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString(),\n        usageCount: 0,\n        isDefault: true\n      },\n      {\n        id: generateId(),\n        name: 'Promotion Alert',\n        content: 'Hi {{name}}! Don\\'t miss our special {{discount}}% discount on {{product}}. Valid until {{expiry}}. Use code: {{code}}',\n        category: 'promotion',\n        tags: ['discount', 'promotion', 'marketing'],\n        variables: ['name', 'discount', 'product', 'expiry', 'code'],\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString(),\n        usageCount: 0,\n        isDefault: true\n      },\n      {\n        id: generateId(),\n        name: 'Appointment Reminder',\n        content: 'Hi {{name}}, this is a reminder about your appointment on {{date}} at {{time}}. Please confirm or reschedule if needed.',\n        category: 'reminder',\n        tags: ['appointment', 'reminder', 'schedule'],\n        variables: ['name', 'date', 'time'],\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString(),\n        usageCount: 0,\n        isDefault: true\n      },\n      {\n        id: generateId(),\n        name: 'Thank You Message',\n        content: 'Thank you {{name}} for your recent purchase! Your order #{{order_id}} has been confirmed and will be delivered by {{delivery_date}}.',\n        category: 'confirmation',\n        tags: ['thanks', 'confirmation', 'order'],\n        variables: ['name', 'order_id', 'delivery_date'],\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString(),\n        usageCount: 0,\n        isDefault: true\n      },\n      {\n        id: generateId(),\n        name: 'Follow Up',\n        content: 'Hi {{name}}, we wanted to follow up on {{topic}}. Please let us know if you have any questions or need assistance.',\n        category: 'follow-up',\n        tags: ['follow-up', 'support', 'customer-service'],\n        variables: ['name', 'topic'],\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString(),\n        usageCount: 0,\n        isDefault: true\n      }\n    ];\n  }\n\n  async createTemplate(templateData) {\n    try {\n      const { name, content, category, tags, variables } = templateData;\n      \n      // Validate required fields\n      if (!name || !content) {\n        throw new Error('Name and content are required');\n      }\n\n      // Check for duplicate name\n      const existingTemplate = this.templates.find(t => t.name.toLowerCase() === name.toLowerCase());\n      if (existingTemplate) {\n        throw new Error('Template with this name already exists');\n      }\n\n      // Extract variables from content if not provided\n      const extractedVariables = variables || this.extractVariables(content);\n\n      const template = {\n        id: generateId(),\n        name: name.trim(),\n        content: content.trim(),\n        category: category?.trim() || 'general',\n        tags: tags || [],\n        variables: extractedVariables,\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString(),\n        usageCount: 0,\n        isDefault: false\n      };\n\n      this.templates.push(template);\n      await this.saveTemplates();\n      \n      logger.info(`Template created: ${name}`);\n      return template;\n    } catch (error) {\n      logger.error('Error creating template:', error);\n      throw error;\n    }\n  }\n\n  async updateTemplate(templateId, updateData) {\n    try {\n      const templateIndex = this.templates.findIndex(t => t.id === templateId);\n      if (templateIndex === -1) {\n        throw new Error('Template not found');\n      }\n\n      const template = this.templates[templateIndex];\n      \n      // Check for duplicate name if being updated\n      if (updateData.name && updateData.name !== template.name) {\n        const existingTemplate = this.templates.find(t => \n          t.name.toLowerCase() === updateData.name.toLowerCase() && t.id !== templateId\n        );\n        if (existingTemplate) {\n          throw new Error('Template with this name already exists');\n        }\n      }\n\n      // Update variables if content changed\n      if (updateData.content && updateData.content !== template.content) {\n        updateData.variables = this.extractVariables(updateData.content);\n      }\n\n      // Update template\n      Object.assign(template, updateData, {\n        updatedAt: new Date().toISOString()\n      });\n\n      await this.saveTemplates();\n      \n      logger.info(`Template updated: ${templateId}`);\n      return template;\n    } catch (error) {\n      logger.error('Error updating template:', error);\n      throw error;\n    }\n  }\n\n  async deleteTemplate(templateId) {\n    try {\n      const templateIndex = this.templates.findIndex(t => t.id === templateId);\n      if (templateIndex === -1) {\n        throw new Error('Template not found');\n      }\n\n      const template = this.templates[templateIndex];\n      \n      // Prevent deletion of default templates\n      if (template.isDefault) {\n        throw new Error('Cannot delete default templates');\n      }\n\n      this.templates.splice(templateIndex, 1);\n      await this.saveTemplates();\n      \n      logger.info(`Template deleted: ${template.name}`);\n      return { success: true };\n    } catch (error) {\n      logger.error('Error deleting template:', error);\n      throw error;\n    }\n  }\n\n  async getTemplates(filters = {}) {\n    try {\n      let filteredTemplates = [...this.templates];\n\n      // Apply filters\n      if (filters.search) {\n        const search = filters.search.toLowerCase();\n        filteredTemplates = filteredTemplates.filter(template =>\n          template.name.toLowerCase().includes(search) ||\n          template.content.toLowerCase().includes(search) ||\n          template.category.toLowerCase().includes(search)\n        );\n      }\n\n      if (filters.category) {\n        filteredTemplates = filteredTemplates.filter(template =>\n          template.category === filters.category\n        );\n      }\n\n      if (filters.tags && filters.tags.length > 0) {\n        filteredTemplates = filteredTemplates.filter(template =>\n          filters.tags.some(tag => template.tags.includes(tag))\n        );\n      }\n\n      // Sort by usage count (most used first), then by name\n      filteredTemplates.sort((a, b) => {\n        if (b.usageCount !== a.usageCount) {\n          return b.usageCount - a.usageCount;\n        }\n        return a.name.localeCompare(b.name);\n      });\n\n      return filteredTemplates;\n    } catch (error) {\n      logger.error('Error getting templates:', error);\n      throw error;\n    }\n  }\n\n  async getTemplate(templateId) {\n    try {\n      const template = this.templates.find(t => t.id === templateId);\n      if (!template) {\n        throw new Error('Template not found');\n      }\n      return template;\n    } catch (error) {\n      logger.error('Error getting template:', error);\n      throw error;\n    }\n  }\n\n  async renderTemplate(templateId, variables = {}) {\n    try {\n      const template = await this.getTemplate(templateId);\n      \n      let renderedContent = template.content;\n      \n      // Replace variables in the template\n      for (const [key, value] of Object.entries(variables)) {\n        const regex = new RegExp(`{{\\\\s*${key}\\\\s*}}`, 'g');\n        renderedContent = renderedContent.replace(regex, value || '');\n      }\n      \n      // Check for unreplaced variables\n      const unreplacedVariables = renderedContent.match(/{{\\s*\\w+\\s*}}/g) || [];\n      \n      // Update usage count\n      template.usageCount = (template.usageCount || 0) + 1;\n      await this.saveTemplates();\n      \n      return {\n        content: renderedContent,\n        originalTemplate: template,\n        unreplacedVariables: unreplacedVariables.map(v => v.replace(/[{}\\s]/g, ''))\n      };\n    } catch (error) {\n      logger.error('Error rendering template:', error);\n      throw error;\n    }\n  }\n\n  extractVariables(content) {\n    const matches = content.match(/{{\\s*(\\w+)\\s*}}/g) || [];\n    return [...new Set(matches.map(match => match.replace(/[{}\\s]/g, '')))];\n  }\n\n  async getCategories() {\n    try {\n      const categories = [...new Set(this.templates.map(t => t.category))];\n      return categories.sort();\n    } catch (error) {\n      logger.error('Error getting categories:', error);\n      throw error;\n    }\n  }\n\n  async getTags() {\n    try {\n      const allTags = this.templates.flatMap(t => t.tags);\n      const tagCounts = {};\n      \n      allTags.forEach(tag => {\n        tagCounts[tag] = (tagCounts[tag] || 0) + 1;\n      });\n      \n      return Object.entries(tagCounts)\n        .sort(([,a], [,b]) => b - a)\n        .map(([tag, count]) => ({ tag, count }));\n    } catch (error) {\n      logger.error('Error getting tags:', error);\n      throw error;\n    }\n  }\n\n  async duplicateTemplate(templateId, newName) {\n    try {\n      const originalTemplate = await this.getTemplate(templateId);\n      \n      const duplicatedTemplate = {\n        ...originalTemplate,\n        id: generateId(),\n        name: newName || `${originalTemplate.name} (Copy)`,\n        createdAt: new Date().toISOString(),\n        updatedAt: new Date().toISOString(),\n        usageCount: 0,\n        isDefault: false\n      };\n      \n      // Check for duplicate name\n      const existingTemplate = this.templates.find(t => \n        t.name.toLowerCase() === duplicatedTemplate.name.toLowerCase()\n      );\n      if (existingTemplate) {\n        duplicatedTemplate.name += ` ${Date.now()}`;\n      }\n      \n      this.templates.push(duplicatedTemplate);\n      await this.saveTemplates();\n      \n      logger.info(`Template duplicated: ${originalTemplate.name} -> ${duplicatedTemplate.name}`);\n      return duplicatedTemplate;\n    } catch (error) {\n      logger.error('Error duplicating template:', error);\n      throw error;\n    }\n  }\n\n  getStats() {\n    const totalTemplates = this.templates.length;\n    const totalUsage = this.templates.reduce((sum, t) => sum + (t.usageCount || 0), 0);\n    const mostUsedTemplate = this.templates.reduce((max, t) => \n      (t.usageCount || 0) > (max.usageCount || 0) ? t : max, this.templates[0]\n    );\n    \n    return {\n      totalTemplates,\n      totalUsage,\n      mostUsedTemplate: mostUsedTemplate ? {\n        name: mostUsedTemplate.name,\n        usageCount: mostUsedTemplate.usageCount || 0\n      } : null,\n      recentTemplates: this.templates\n        .sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt))\n        .slice(0, 5)\n        .map(t => ({\n          id: t.id,\n          name: t.name,\n          category: t.category,\n          createdAt: t.createdAt\n        }))\n    };\n  }\n}\n\nmodule.exports = TemplatesService;