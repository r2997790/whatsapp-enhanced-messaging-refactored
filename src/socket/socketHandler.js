const logger = require('../utils/logger');\n\n/**\n * Setup Socket.IO event handlers\n * @param {Object} io - Socket.IO server instance\n * @param {Object} whatsappService - WhatsApp service instance\n */\nfunction setupSocketEvents(io, whatsappService) {\n  io.on('connection', (socket) => {\n    logger.info(`Client connected: ${socket.id}`);\n    \n    // Send current WhatsApp status on connection\n    const status = whatsappService.getStatus();\n    socket.emit('whatsapp_status', status);\n    \n    // Handle client disconnection\n    socket.on('disconnect', (reason) => {\n      logger.info(`Client disconnected: ${socket.id}, reason: ${reason}`);\n    });\n    \n    // Handle request for current status\n    socket.on('get_status', () => {\n      try {\n        const status = whatsappService.getStatus();\n        socket.emit('whatsapp_status', status);\n      } catch (error) {\n        logger.error('Error getting status for socket:', error);\n        socket.emit('error', { message: 'Failed to get WhatsApp status' });\n      }\n    });\n    \n    // Handle request for QR code\n    socket.on('request_qr', () => {\n      try {\n        const status = whatsappService.getStatus();\n        if (status.qrCode) {\n          socket.emit('qr_code', { qrCode: status.qrCode });\n        } else if (status.isConnected) {\n          socket.emit('whatsapp_ready', { \n            status: 'connected',\n            message: 'WhatsApp is already connected'\n          });\n        } else {\n          socket.emit('qr_pending', { \n            message: 'QR code will be available shortly'\n          });\n        }\n      } catch (error) {\n        logger.error('Error handling QR request:', error);\n        socket.emit('error', { message: 'Failed to get QR code' });\n      }\n    });\n    \n    // Handle single message send request\n    socket.on('send_message', async (data) => {\n      try {\n        const { phoneNumber, message, templateId, variables } = data;\n        \n        if (!phoneNumber || (!message && !templateId)) {\n          socket.emit('message_error', {\n            error: 'Phone number and message (or templateId) are required'\n          });\n          return;\n        }\n        \n        // This would typically be handled by the REST API,\n        // but we can support real-time messaging through sockets too\n        await whatsappService.addToQueue(phoneNumber, message);\n        \n        socket.emit('message_queued', {\n          phoneNumber,\n          message: 'Message added to queue'\n        });\n        \n      } catch (error) {\n        logger.error('Error handling socket message send:', error);\n        socket.emit('message_error', {\n          error: error.message\n        });\n      }\n    });\n    \n    // Handle bulk message request\n    socket.on('send_bulk_messages', async (data) => {\n      try {\n        const { contacts, message, campaignName } = data;\n        \n        if (!contacts || !contacts.length || !message) {\n          socket.emit('bulk_message_error', {\n            error: 'Contacts and message are required'\n          });\n          return;\n        }\n        \n        // Add all messages to queue\n        for (const contact of contacts) {\n          await whatsappService.addToQueue(contact.phone, message);\n        }\n        \n        socket.emit('bulk_message_started', {\n          total: contacts.length,\n          campaignName: campaignName || `Campaign ${Date.now()}`\n        });\n        \n      } catch (error) {\n        logger.error('Error handling socket bulk message send:', error);\n        socket.emit('bulk_message_error', {\n          error: error.message\n        });\n      }\n    });\n    \n    // Handle request to stop/pause messaging\n    socket.on('pause_messaging', () => {\n      try {\n        // Clear the queue (this is a simple implementation)\n        whatsappService.messagingQueue = [];\n        socket.emit('messaging_paused', {\n          message: 'Messaging queue cleared'\n        });\n      } catch (error) {\n        logger.error('Error pausing messaging:', error);\n        socket.emit('error', { message: 'Failed to pause messaging' });\n      }\n    });\n    \n    // Handle logout request\n    socket.on('logout_whatsapp', async () => {\n      try {\n        await whatsappService.logout();\n        socket.emit('logout_success', {\n          message: 'Logged out successfully'\n        });\n      } catch (error) {\n        logger.error('Error logging out via socket:', error);\n        socket.emit('logout_error', {\n          error: error.message\n        });\n      }\n    });\n    \n    // Handle restart request\n    socket.on('restart_whatsapp', async () => {\n      try {\n        await whatsappService.destroy();\n        await whatsappService.initialize();\n        socket.emit('restart_success', {\n          message: 'WhatsApp client restarted'\n        });\n      } catch (error) {\n        logger.error('Error restarting WhatsApp via socket:', error);\n        socket.emit('restart_error', {\n          error: error.message\n        });\n      }\n    });\n    \n    // Handle request for messaging statistics\n    socket.on('get_stats', () => {\n      try {\n        const status = whatsappService.getStatus();\n        socket.emit('messaging_stats', status.stats);\n      } catch (error) {\n        logger.error('Error getting stats via socket:', error);\n        socket.emit('error', { message: 'Failed to get statistics' });\n      }\n    });\n    \n    // Handle ping for connection check\n    socket.on('ping', () => {\n      socket.emit('pong', {\n        timestamp: new Date().toISOString(),\n        server: 'WhatsApp Enhanced Messaging'\n      });\n    });\n  });\n  \n  // Handle server-side events and broadcast to all clients\n  \n  // Broadcast messaging statistics updates\n  const originalEmit = io.emit.bind(io);\n  \n  // Override emit to add logging for important events\n  io.emit = function(event, data) {\n    if (['qr_code', 'whatsapp_ready', 'whatsapp_disconnected', 'message_sent', 'message_failed'].includes(event)) {\n      logger.debug(`Broadcasting event: ${event}`);\n    }\n    return originalEmit(event, data);\n  };\n  \n  logger.info('Socket.IO event handlers setup complete');\n}\n\n/**\n * Broadcast an event to all connected clients\n * @param {Object} io - Socket.IO server instance\n * @param {string} event - Event name\n * @param {Object} data - Event data\n */\nfunction broadcastToAll(io, event, data) {\n  try {\n    io.emit(event, data);\n    logger.debug(`Broadcasted ${event} to all clients`);\n  } catch (error) {\n    logger.error(`Error broadcasting ${event}:`, error);\n  }\n}\n\n/**\n * Broadcast an event to a specific room\n * @param {Object} io - Socket.IO server instance\n * @param {string} room - Room name\n * @param {string} event - Event name\n * @param {Object} data - Event data\n */\nfunction broadcastToRoom(io, room, event, data) {\n  try {\n    io.to(room).emit(event, data);\n    logger.debug(`Broadcasted ${event} to room ${room}`);\n  } catch (error) {\n    logger.error(`Error broadcasting ${event} to room ${room}:`, error);\n  }\n}\n\n/**\n * Get number of connected clients\n * @param {Object} io - Socket.IO server instance\n * @returns {number} Number of connected clients\n */\nfunction getConnectedClientsCount(io) {\n  return io.engine.clientsCount;\n}\n\nmodule.exports = {\n  setupSocketEvents,\n  broadcastToAll,\n  broadcastToRoom,\n  getConnectedClientsCount\n};"